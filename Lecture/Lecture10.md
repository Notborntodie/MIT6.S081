# File System

[TOC]

现在来介绍文件系统，这将使用三讲的时间，这讲和下一讲将使用`Xv6`,第三讲将基于`Linux`。我们一直在使用文件系统，文件系统有如下的特性

* **User-friendly names/pathname**:文件系统提供了对于用户友好的文件名，也就是**层级**的路径文件名。这可以帮助用户组织目录中的文件。
* **Share files between users/processes **:通过将文件命名为易记的名字，可以便于用户之间和进程之间更简单地共享文件。
* **Persistence/durability** :我们已经看过了Xv6的诸多子系统---内存，进程等等，文件系统和他们最大的不一样便在于提供持久化。文件系统的持久化一个例子就是如果现在关闭了计算机，过几天文件依然在计算机的相同位置(disk中)，这和一旦计算机重启则会消失的进程等其他资源(在内存中)完全不同。

**我们现在要学习文件系统内部的机制**

## 文件系统的有趣机制

文件系统和OS其他子系统首先不一样在于：它所在的硬件是速度通常远慢于内存的磁盘(disk)。文件系统内部还有一些比较有趣的机制：

* **Abstraction is useful**：还记得在Lecture2的时候，我们曾说过文件是对硬件(disk)的抽象，文件系统是如何做到这一点的？
* **Crash safety** : 这和持久化有关，即如果使用文件系统的时候，计算机突然崩溃了。那么需要保证
  1. 重启以后计算机的文件系统依然保持完好。
  2. 磁盘上的文件数据依然存在，且用户可以使用大部分文件。
* **Disk layout** ：和memory layout类似，在文件系统需要在**磁盘中**(重启的时候，数据能全部恢复)通过维护一些数据结构来表示文件或者目录的结构和内容，在Xv6中，这些数据结构比较简单，真实的文件系统则会更复杂。

* **Performance** : disk的速度很慢，例如向SSD disk写数据通常是一个毫秒(ms)级别的操作。在1ms里,CPU和内存之间可以做很多工作，所以考虑到性能

  1. 一方面我们要避免进行读写disk(即I/O操作)，所以提供了**buffer cache**。
  2. 另一方面我们可以让CPU的运行和I/O操作==并行==进行，所以需要进程间的==并发==（concurrency）支持。

  *这里说并行是指I/O操作和进程之间，而并发是指进程之间*

  比如，一个进程需要去做路径名的查找，它需要和disk交互，那么它交互过程中等待I/O结束时，另一个进程便可以在CPU上运行。

## 文件系统实现

我们先来看文件系统的API

1. ```c
   fd=open("x/y",FLAG);
   ```

   `open`系统调用将会在目录x创建文件y，并返回文件描述符。

2. ```c
   write(fd,"abc",3);
   ```

   `write`系统调用将通过文件描述符向文件写入"abc" 这三个字符。

3. ```c
   link("x/y","x/z");
   ```

   `link`系统调用可以用来给刚才创建的"x/y"文件创建另一个名字

4. ```c
   unlink("x/y")
   write(fd,"def",3);
   ```

   `unlink`系统调用可以用来删除特定的文件名,此时只要文件描述符不关

现在我们透过这些接口可以窥见文件系统实现的一些细节。

* `open`接口使用的路径名是由用户选择的字符串，而不是一串数字。
* `write`接口并没有使用offset的参数，这意味着==文件系统一定维护了文件的offset==。下一次写文件的时候会从第4个数据开始写。



